# Transactions
Redis에서 트랜잭션이 동작하는 원리

Redis 트랜잭션은 여러 명령어들의 그룹이 한 번에 실행되게 해줍니다. `MULTI`, `EXEC`, `DISCARD` 그리고 `WATCH` 명령어로 이루어집니다.
Redis 트랜잭션은 두 개의 중요한 점을 보장합니다.

- 트랜잭션 안의 모든 명령은 직렬화되어 순차적으로 실행됩니다. 다른 클라이언트로부터 들어오는 요청은 절대 Redis 트랜잭션 실행 중간에 처리되지
않습니다. Redis 트랜잭션을 통해 여러 명령들이 하나의 독립된 연산으로 처리됨으로 보장합니다.


- `EXEC` 명령어는 트랜잭션 내의 모든 명령을 트리거합니다. 따라서 만약 클라이언트가 `EXEC` 명령 호출 전에 서버와의 연결이 끊기면, 그 어떤
연산도 처리되지 않습니다. 하지만 `EXEC` 명령이 호출되면 모든 연산은 처리됩니다. 만약 **append-only-file**을 사용하면 Redis는 단일 write(2)
시스템 콜을 통해 트랜잭션을 디스크에 기록함을 보장합니다. 그러나 Redis 서버가 충돌나거나, 시스템 관리자가 강제로 종료한 경우, 부분적 쓰기가 발생할 수도
있습니다. Redis는 이를 재시작에 감지하며, 에러를 발생시키며 종료될 것입니다. redis-check-aof 도구를 사용하여 AOF에서 부분적으로 기록된 
트랜잭션을 제거해 서버가 다시 시작될 수 있도록 복구할 수 있습니다.

버전 2.2부터는 Redis는 위의 두 개의 항목에 더해, CAS 연산과 매우 유사한 방식의 낙관적 락 형태로 보장합니다. 이것에 대한 내용 해당 페이지의
추후에 기술하겠습니다.

# Usage
***

Redis 트랜잭션은 `MULIT` 명령을 통해 진입할 수 있습니다. 해당 명령은 항상 OK를 반환할 것입니다. 이 시점부터 사용자는 여러 명령어들을 
입력할 수 있습니다. 이 명령어들을 실행하는 대신, Redis는 큐에 쌓을 것입니다. 모든 명령은 `EXEC`이 호출되면 실행됩니다.

`DISCARD` 호출을 통해 트랜잭션 큐를 비우고 트랜잭션을 종료할 수 있습니다.

다음의 예제는 foo 키와 bar 키를 원자적으로 증가시킵니다.

~~~redis
> MULTI
OK
> INCR foo
QUEUED
> INCR bar
QUEUED
> EXEC
1) (integer) 1
2) (integer) 1
~~~

위 세션에서 알 수 있듯이 `EXEC` 명령은 응답 배열을 반환하며, 각 요소는 트랜잭션 내에서 실행된 개별 명령의 응답입니다. 이 응답은 명령이 입력된
순서대로 반환됩니다.

Redis 연결이 `MULTI` 요청의 컨텍스트 안에 있는 경우, 모든 명령은 응답으로 `QUEUED` 문자열을 반환합니다(Redis 프로토콜 관점에서는
Status Reply로 전송됨). 큐에 적재된 명령어는 `EXEC` 명령이 호출될 떄 실행되도록 예약된 것입니다.

# Errors inside a transaction
***

트랜잭션 중간에는 두 가지 명령 오류를 마주할 수 있습니다:

- 큐에 명령을 적재하는 것을 실패해 `EXEC` 호출 전에 오류가 발생합니다. 예를 들어, 명령어가 문법적으로 틀렸거나(틀린 인자 개수, 틀린 명령어 ...),
또는 메모리 부족같은 치명적인 상황이 발행할 수도 있습니다(`maxmemory` 설정을 통해 서버에 메모리 제한이 걸린 경우).
- `EXEC` 호출 후에 명령어가 실패할 수도 있습니다. 예를 들어, 키에 잘못된 값으로 연산을 시도할 수도 있습니다(문자열 타입의 값에 배열 연산을 적용한다든지).

Redis 2.6.5부터는 서버가 명령을 누적하는 동안 오류를 감지하면 트랜잭션 실행을 거절하고 `EXEC` 오류를 반환하고 트랜잭션을 폐기합니다.

> **Redis 2.6.5 이하를 사용할 시 주의사항**: Redis 2.6.5 전에는 클라이언트들이 `QUEUED` 응답을 통해 직접 `EXEC` 호출 전에 발생한 오류를 감지해야
했습니다.: 만약 `QUEUED` 응답을 받을 경우, 큐에 잘 적재된 것이고, 아니면 Redis가 오류를 반환할 것입니다. 큐에 명령어들을 적재하다 오류가 발행하면,
대부분의 클라이언트들은 트랜잭션을 취소하고 폐기할 것입니다. 반면에, 클라이언트가 트랜잭션을 진행하기로 한 경우, `EXEC` 명령은 성공적으로 큐에
적재된 명령어들만 실행할 것입니다.

반면, `EXEC` 호출 후에 발행하는 오류들에 대해서는 특별하게 처리하지 않습니다: 즉 트랜잭션 중 일부 명령이 실패해도 나머지 명령들은 그대로 실행됩니다.

이러한 동작은 프로토콜 수준에서 보면 더 명확합니다. 다음의 예제에서는 문법이 올바르더라도 실행 시 실패하는 명령이 포함된 경우입니다:

~~~redis
Trying 127.0.0.1...
Connected to localhost
Escape character is '^]'/
MULTI
+OK
SET a abc
+QUEUED
LPOP a
+QUEUED
EXEC
*2
+OK
-WRONGTYPE Operation against a key holding the wrong kind of value
~~~

`EXEC`는 두 요소로 구성된 bulk string 응답을 반환했으며, 하나는 OK 코드이고 다른 하나는 오류 응답입니다. 사용자에게 이 오류를 전달하는
방식은 클라리언트측 라이브러리에 달려있습니다.

중요한 것은 명령이 실패하더라도, 큐잉된 다른 명령들은 여전히 실행된다는 점입니다. - Redis는 오류가 발생해도 명령 처리를 중단하지 않습니다.

다른 예시로, telnet을 사용한 wire 프로토콜을 통해 문법 오류가 어떻게 즉시 보고되는지를 보여줍니다:

~~~redis
MULTI
+OK
INCR a b c
-ERR wrong number of arguments for 'incr' command
~~~

이번에는 문법 오류로 인해 잘못된 INCR 명령이 전혀 큐에 추가되지 않았습니다. 

# What about rollbacks?
***

Redis는 트랜잭션의 롤백을 지원하지 않습니다. 그 이유는 롤백을 지원하게 되면 Redis의 단순성과 성능에 중대한 영향을 미치기 때문입니다.

# Discarding the command queue
***

`DISCARD`는 트랜잭션을 취소하는데 사용될 수 있습니다. 다음의 예시에서는, 어떤 명령도 실행되지 않으며 연결 상태는 정상 상태로 돌아옵니다.

~~~redis
> SET foo 1
OK
> MULTI
OK
> INCR foo
QUEUED
> DISCARD
OK
> GET foo
"1"
~~~

# Optimistic locking using check-and-set
***

`WATCH` 명령은 Redis 트랜잭션에 CAS 동작을 제공하기 위해 사용됩니다.

`WATCH`에 등록된 키들은 변경 사항에 대해 감시를 받습니다. `EXEC` 호출 전에 어떤 키라도 변경이 감지되면, 전체 트랜잭션이 취소되며, `EXEC`
호출은 트랜잭션이 실패함을 알려주기 위해 NULL을 반환합니다.

예시로, 어떤 키의 값을 원자적으로 1 증가시킬 필요가 있는데 Redis가 `INCR`을 지원하지 않는다고 가정해봅시다.

첫 번째 시도는 다음과 같을 수 있습니다:

~~~redis
val = GET mykey
val = val + 1
SET mykey $val
~~~

이 방식은 동일한 시점에 하나의 클라이언트에 대해서만 안정적으로 동작합니다. 만약 여러 클라이언트들이 같은 키에 대해 동시다발적으로 증가시키려고 하면
경쟁 상태가 발생할 것입니다. 예를 들어, 클라이언트 A하고 클라이언트 B가 기존의 값을 조회합니다(ex: 10). 값은 두 클라이언트에 의해 11로 증가될 것이며,
`SET`을 통해 키에 대한 값을 설정할 것입니다. 그러면 최종적인 값은 12가 아닌 11이 될 것입니다.

`WATCH` 덕분에 우리는 이러한 문제를 아주 잘 모델링할 수 있습니다:

~~~redis
WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
~~~

위의 코드를 사용해서, 경쟁 상태이거나, 다른 클라이언트가 `WATCH`하고 `EXEC` 사이에 값을 변경하려고 한다면 트랜잭션이 실패할 것입니다.

우리는 단지 새로운 경쟁 상태가 일어나지 않기를 바라면서 같은 작업을 반복하면 됩니다. 이러한 형태의 락을 낙관적 락이라고 합니다. 많은 사용 사례에서
여러 클라이언트들은 다른 값에 접근할 것이며, 따라서 위와 같은 충돌은 잘 일어나지 않습니다. 그래서 보통은 위 작업을 반복할 필요는 없습니다.

# WATCH explained
***

그렇다면 `WATCH`는 실질적으로 무엇을 할까요? `WATCH`는 `EXEC` 명령을 조건부로 만들어줍니다: Redis에게 `WATCH`한 키들이 변경되지 않았을 때만
트랜잭션을 수행하라고 조건을 주는 겁니다. 여기서 변경에는 클라이언트가 수행하는 변경뿐만 아니라 Redis 자체적으로 수행하는 만료나 제거 작업도
포함됩니다. 만약 `WATCH`한 시점과 `EXEC`을 수신한 시점 사이에 해당 키들 중 하나라도 변경되었다면 전체 트랜잭션은 중단될 것입니다.

**참고**

- Redis 버전 6.0.9 이전 버전에서는 만료된 키는 트랜잭션을 중단시키지 않습니다. 더 자세한 내용은 다음을 보세요.
  - https://github.com/redis/redis/pull/7920
- 트랜잭션 내의 명령어들은 `EXEC`가 호출될 때까지 저장되기만 하므로, `WATCH` 조건을 트리거하지 않습니다.

`WATCH`는 여러 번 호출될 수 있습니다. 모든 `WATCH`는 그 시점부터 `EXEC`가 호출되기 전까지의 변경을 감시하게 됩니다. 또한 한 번의 호출에 여러
키를 전달하는 것도 가능합니다. 

`EXEC`가 호출되면, 트랜잭션이 실행되었든 중단되었든 상관없이 모든 키에 대한 WATCH 상태는 자동으로 해제됩니다.
마찬가지로 클라이언트 연결이 종료될 때도, 모든 `WATCH`는 해제됩니다.

또한, `UNWATCH`를 통해 감시된 모든 키들을 해제할 수 있습니다. 낙관적 락을 사용하여 일부 키를 감시했지만, 키의 현재 값을 읽어본 뒤 트랜잭션을
진행하지 않기로 했을 때 유용합니다. 이 경우, `UNWATCH`를 호출해 해당 연결은 새로운 트랜잭션을 자유롭게 수행할 수 있습니다.

## Using WATCH to implement ZPOP

`WATCH`를 Redis에서 지원하지 않는 새로운 원자적 연산을 구현하는 좋은 예시는 `ZPOP`을 구현하는 것입니다(`ZPOPMIN`, `ZPOPMAX` 및 그들의 blocking
버전은 버전 5.0에서 추가되었습니다.). Sorted set에서 가장 낮은 점수를 가진 원자적으로 pop하는 명령입니다. 다음은 가장 간단한 구현 방법입니다:

~~~redis
WATCH zset
element = ZRANGE zset 0 0
MULTI
ZREM zset element
EXEC
~~~

만약 `EXEC`가 실패하면 다시 반복하면 됩니다.

# Redis scripting and transactions
***

Redis에서 트랜잭션과 유사한 동작을 고려할 때, 트랜잭션널하게 동작하는 Redis 스크립트 역시 중요한 요소입니다. Redis 트랜잭션으로 할 수 있는
모든 작업은 스크립트로도 수행할 수 있으며, 보통 스크립트가 더 간단하고 빠르게 실행됩니다.