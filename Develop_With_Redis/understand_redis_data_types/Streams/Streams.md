# Redis Streams
Redis Streams에 대한 소개

Redis Stream은 append-only 로그같은 방식으로 동작하는 자료 구조입니다. 하지만, 일반적인 append-only 로그의 한계를
극복할 수 있는 여러 연산을 제공합니다. 시간복잡도 O(1)의 랜덤 액세스와 소비자 그룹같은 복잡한 소비 전략등이 포함됩니다.
Streams를 통해 이벤트를 실시간으로 기록하고 동시에 배포할 수 있습니다. 다음은 Redis Stream의 사용사례입니다:

- 이벤트 소싱 (예: 사용자 행동, 클릭)
- 센서 모니터링 (예: 장비들 감시)
- 알림 (예: 별개의 스트림에 각 사용자의 알림 저장)

Redis는 각 스트림 항목에 대해 고유한 ID를 생성합니다. 이 ID를 가지고 관련 항목을 조회하거나, 스트림 내에서
이후의 항목들을 읽거나 처리할 수 있습니다. 이 ID들은 시간에 관계되어 있기 때문에, 이 문서에 표시된 ID는 실제 Redis 
인스턴스에서 보게 되는 ID와 다를 수 있습니다.

Redis 스트림은 여러 트리밍 전략(스트림이 무한으로 늘어나는 것을 방지하기 위함)과 여러가지 소비 전략을 지원합니다.(
`XREAD`, `XREADGROUP`, `XRANGE`를 확인해보세요.)

## Basic commands
***
- `XADD`는 새 항목을 스트림에 추가합니다.
- `XREAD`는 지정된 위치에서 시간 순으로 앞으로 이동하면서 하나 이상의 항목을 읽습니다.
- `XRANGE`는 두 개의 입력된 항목 ID 사이의 항목들의 범위를 반환합니다.
- `XLEN`은 스트림의 길이를 반환합니다.

다음 링크에서 스트림 명령어들의 전체 목록을 확인하세요.
- https://redis.io/docs/latest/commands/?group=stream

# Examples
***
- 선수들이 체크포인트를 지날 때마다, 각 선수에 대한 정보(이름, 속도, 위치, 장소 ID)를 기록한 스트림 항목을 추가합니다:
~~~redis
> XADD race:france * rider Castilla speed 30.2 position 1 location_id 1
"1692632086370-0"
> XADD race:france * rider Norem speed 28.8 position 3 location_id 1
"1692632094485-0"
> XADD race:france * rider Prickett speed 29.7 position 2 location_id 1
"1692632102976-0"
~~~

- ID 1692632086370-0에서 시작하는 두 스트림 항목들을 읽습니다:
~~~redis
> XRANGE race:france 1692632086370-0 + COUNT 2
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
2) 1) "1692632094485-0"
   2) 1) "rider"
      2) "Norem"
      3) "speed"
      4) "28.8"
      5) "position"
      6) "3"
      7) "location_id"
      8) "1"
~~~

- 스트림 끝에서 시작하여 최대 100개의 새 스트림 항목을 읽고, 항목이 쓰여지지 않으면 최대 300밀리초 동안 대기하려면
다음과 같습니다:
~~~redis
> XREAD COUNT 100 BLOCK 300 STREAMS race:france $
(nil)
~~~

## Performance
***

스트림에 새로운 항목을 추가하는 작업은 시간복잡도 O(1)입니다. 단일 항목에 대한 접근 시간복잡도 O(n)이고, 여기서
n은 ID의 길이입니다. 스트림 ID는 보통 짧고 고정된 길이를 가지기 때문에, 보통 상수 시간에 처리됩니다. 그 이유에 대해
알고 싶다면 스트림은 **radix trees**로 구현되어 있다는 것을 참고하면 됩니다.
- https://en.wikipedia.org/wiki/Radix_tree
> Radix Tree
Radix 트리는 압축된 Trie 구조라고 볼 수 있다. Trie 구조에서는 한 글자씩 노드에 할당하지만, Radix 트리는 
여러 문자를 한 노드에 저장해 압축한다.
DNS 룩업, 라우팅 테이블등에 사용이 된다.

간단히 말해서, Redis 스트림은 매우 효율적인 삽입과 읽기 성능을 가졌습니다. 시간 복잡도에 대한 내용은
각 명령어 페이지에서 확인할 수 있습니다.

## Stream basics
***
스트림은 append-only 자료구조입니다. 기본적인 쓰기 명령어인 `XADD`는 특정한 스트림에 새로운 항목을 추가합니다.

각 스트림 항목은 하나 이상의 키-값 쌍들을 가지며, 이는 dictionary 또는 Redis 해시와 비슷합니다:
~~~redis
> XADD race:france * rider Castilla speed 29.9
position 1 location_id 2
"1692632147973-0"
~~~

위의 `XADD` 호출은 ` rider: Castilla, speed: 29.9, position: 1, location_id: 2`을 `race:france` 스트림에
추가됩니다. 이때 1692632147973-0라는 자동 생성된 항목 ID를 반환합니다. 첫 번째 인자는 키의 이름이고, 두 번째 인자는 
스트림 내의 각 항목을 식별하는 ID입니다. 하지만, 이 사례에서는 *를 사용했기 때문에 Redis 서버가 자동으로 새로운 ID를
생성해줍니다. 모든 새로운 ID는 단조적으로 증가합니다. 쉽게 바꿔 말하면, 모든 새로운 항목은 기존의 항목들과 비교해서 항상
큰 ID 값을 가질 것입니다. ID를 서버가 자동으로 생성하는 방식이 거의 항상 바람직하며, 명시적으로 ID를 지정해야 하는 경우는 
매우 드뭅니다. 이에 대해서는 이후에 더 설명합니다. 각 스트림 항목이 ID를 가지고 있다는 점은 로그와 비슷하며, 로그에서는
행 번호나 바이트 오프셋을 통해 항목을 식별할 수 있는 것처럼 말입니다. `XADD` 예시로 돌아와서, 키 이름과 ID 뒤에는
스트림 항목을 구성하는 키-값들이 인자로 들어옵니다.

`XLEN`을 통해 스트림 안의 항목들의 개수를 조회할 수 있습니다:
~~~redis
> XLEN race:france
(integer) 4
~~~

### Entry IDs
`XADD`로 반환받은 항목 ID는 스트림 내에서 각 항목을 고유하게 식별하며, 두 부분으로 구성됩니다:
~~~redis
<millisecondsTime>-<sequenceNumber>
~~~

밀리초 부분은 스트림 ID를 생성하는 Redis 노드의 로컬 시간입니다. 하지만 만약 현재 밀리초 시간이 이전의 항목 시간보다
작으면 이전 항목 시간을 사용이 대신 사용됩니다. 이는 시스템 시계가 되돌아가는 일이 발생해도 ID를 단조적으로 증가시키는 것을
유지시키기 위해서 입니다. 시퀸스 번호는 같은 밀리초 내에서 생성된 항목들에 대해 사용됩니다. 이 시퀸스 번호는 64 비트
정수이기 때문에, 현실적으로는 같은 밀리초 안에서 생성할 수 있는 항목 수에 제한이 없습니다.

이러한 형식의 ID는 처음에는 이상해 보일 수 있지만, ID에 시간이 들어간 이유가 있습니다. 그 이유는 Redis 스트림은
ID로 범위 질의를 지원하기 때문입니다. ID가 항목이 생성된 시간에 관계되어 있기 때문에, 시간을 가지고 질의를 할 수 있습니다.
이것에 대해 추후 `XRANGE` 명령어를 살펴보면서 더 살펴보겠습니다.

여러 이유로 시간과 관련되지 않고, 실제로는 외부 시스템의 다른 ID와 연관된 증가하는 ID가 필요하다면, 앞서 언급했듯이
`XADD` 명령은 자동 생성을 트리거하는 * 와일드카드 ID 대신 명시적으로 ID를 생성할 수 있습니다. 다음의 예시에서
보겠습니다:
~~~redis
> XADD race:usa 0-1 racer Castilla
0-1
> XADD race:usa 0-2 racer Norem
0-2
~~~

이 사례에서는 최소 ID 0-1임을 주의하세요. 이전에 사용된 ID보다 작거나 동일한 ID는 허용되지 않습니다:
~~~redis
> XADD race:usa 0-1 racer Prickett
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item
~~~

만약 Redis 7 버전 이후를 사용하신다면, 밀리초 시간 부분만 포함된 명시적 ID를 제공할 수도 있습니다. 이 경우
시퀸스 번호 부분은 자동으로 생성됩니다. 다음과 같은 문법으로 사용할 수 있습니다:
~~~redis
> XADD race:usa 0-* racer Prickett
0-3
~~~

# Getting data from Streams
***

이제 우리는 스트림에 `XADD`를 이용하여 항목들을 추가할 수 있습니다. 하지만, 스트림에 데이터를 추가하는 것은 이제
명확하지만, 스트림에서 질의를 통해 데이터를 추출하는 것은 아직입니다. 로그 파일에 대한 비유를 계속하자면,
한 가지 명백한 방법은 우리가 일반적으로 Unix 명령어 `tail -f`로 하는 작업을 흉내 내는 것입니다. 즉, 스트림에 새로 추가되는
메시지를 얻기 위해 감시할 수 있습니다. 주의할 점은, Redis의 블로킹 리스트 연산들에서는 특정 요소가 pop과 같은 연산으로
블로킹 중인 하나의 클라이언트에게만 전달되는 반면, 스트림에서는 새로 추가된 메시지를 여러 소비자들이 볼 수 있기를 원한다는
점입니다. 스트림이 메시지를 여러 클라이언트에게 팬아웃할 수 있기를 원하는 것입니다.

하지만, 이것은 단지 하나의 접근 방법일 뿐입니다. 다른 방식으로 스트림을 볼 수 있습니다: 메시징 시스템이 아닌, 시계열 
저장소로 말이죠. 이 사례에서도 새로 추가된 메시지를 수신하는 것은 용이하지만, 또 다른 자연스러운 쿼리 방식은 시간 범위에
따라 메시지를 조회하거나, 커서를 사용하여 전체 이력을 점진적으로 확인하는 방식입니다. 이는 또 다른 유용한 접근 방식입니다.

마지막으로, 스트림을 소비자의 관점에서 바라본다면, 스트림에 접근하는 다른 방식이 필요할 수 있습니다. 스트림의 메시지들을
파티셔닝하여 여러 소비자에게 분할하여 처리하는 방식입니다. 소비자 그룹은 스트림에 도착하는 일부 메시지만 볼 수 있으며,
이러한 방식에서는 여러 다른 소비자들에게 메시지 처리를 분산시켜 확장성을 가져갈 수 있습니다: 각 소바자들은 처리해야할 
다른 메시지들을 받게됩니다. 이 방식은 Kafka(TM)가 소비자 그룹을 관리하는 것과 동일합니다. 소비자 그룹을 통해 메시지를
읽는 것은 Redis 스트림의 또 하나의 흥미로운 기능입니다.

Redis 스트림은 위에서 설명한 세 가지 쿼리 모드를 서로 다른 명령어를 통해 지원합니다. 다음 섹션에서 모두 소개할 것이며, 
가장 간단하고 직관적인 것부터 시작하겠습니다: **범위 질의**

## Querying by range: XRANGE and XREVRANGE
스트림을 범위 질의하려면 시작 ID와 끝 ID만 필요합니다. 질의를 통해 반환되는 범위에는 시작과 끝 ID가 포함됩니다. 따라서
해당 범위는 포함 범위입니다. 특수한 두 ID -와 +는 각각 가장 작은 ID와 가장 큰 ID를 의미합니다.
~~~redis
> XRANGE race:france - +
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
2) 1) "1692632094485-0"
   2) 1) "rider"
      2) "Norem"
      3) "speed"
      4) "28.8"
      5) "position"
      6) "3"
      7) "location_id"
      8) "1"
3) 1) "1692632102976-0"
   2) 1) "rider"
      2) "Prickett"
      3) "speed"
      4) "29.7"
      5) "position"
      6) "2"
      7) "location_id"
      8) "1"
4) 1) "1692632147973-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "29.9"
      5) "position"
      6) "1"
      7) "location_id"
      8) "2"
~~~

반환받은 각 항목은 두 아이템의 배열입니다: ID와 키-값 쌍들의 리스트입니다. 이전에 언급했듯이 항목 ID는 시간과 관게가 있으며,
ID의 '-' 문자 왼쪽에 있는 스트림 항목이 생성된 시점의 로컬 노드의 Unix 밀리초 시간입니다 (스트림은 `XADD` 명령을
명시적 복제하기 때문에, 복제본에서도 마스터와 동일한 ID를 갖게 됨에 주의하세요). 이것은 `XRANGE`를 통해 
시간을 범위로 질의할 수 있다는 것을 의미합니다. 이를 위해서 ID의 시퀸스 부분을 생략할 수도 있습니다: 범위의 시작 ID에서
생략되면 0으로 간주되고, 끝 부분에서 생략되면 가능한 최대의 시퀸스 번호로 간주됩니다. 이 방식으로 두 Unix 밀리초 시간 사이에서
생성된 모든 항목들을 가져올 수 있습니다(포함 범위로). 예시로, 2 밀리초 동안을 질의하고 싶으면 다음과 같이 할 수 있습니다:
~~~redis
> XRANGE race:france 1692632086369 1692632086371
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
~~~

해당 범위에서는 하나의 항목밖에 존재합니다. 하지만, 실제 데이터셋에서는 수 시간으로 질의할 수 있으며, 2 밀리초 안에 
수많은 요소들이 들어있어 결과가 방대할 수 있습니다. 이러한 이유로, `XRANGE`는 끝에 **COUNT** 옵션을 제공합니다.
개수를 명시하는 방식으로 첫 N개의 항목들만 가져올 수 있습니다. 만약 더 원하면, 마지막으로 반환된 ID를 1 증가시켜서 
다시 질의하면 됩니다. 다음의 예시에서 살펴봅시다. `race:france` 스트림에 4개 항목이 있다고 가정해 봅시다. 반복을
시작하기 위해서 전체 범위를 질의하되, count 2로 2개의 요소만 가져오겠습니다.
~~~redis
> XRANGE race:france - + COUNT 2
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
2) 1) "1692632094485-0"
   2) 1) "rider"
      2) "Norem"
      3) "speed"
      4) "28.8"
      5) "position"
      6) "3"
      7) "location_id"
      8) "1"
~~~

다음 두 요소를 조회하기 위해서 반환받은 마지막 ID(1692632094485-0)에 접두사 '('를 붙입니다. 이렇게 하면
(1692632094485-0 이라는 배타적 범위(exclusive range)가 되고 해당 값을 다음 `XRANGE`에 사용할 수 있습니다:
~~~redis
> XRANGE race:france (1692632094485-0 + COUNT 2
1) 1) "1692632102976-0"
   2) 1) "rider"
      2) "Prickett"
      3) "speed"
      4) "29.7"
      5) "position"
      6) "2"
      7) "location_id"
      8) "1"
2) 1) "1692632147973-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "29.9"
      5) "position"
      6) "1"
      7) "location_id"
      8) "2"
~~~

이제 4개의 요소가 들어있는 스트림에서 4개 모두 조회하였으며, 추가적으로 더 조회할 경우 빈 배열을 반환받게 됩니다:
~~~redis
> XRANGE race:france (1692632147973-0 + COUNT 2
(empty array)
~~~

`XREVRANGE`는 `XRANGE`의 반환 값을 거꾸로 받는 것이므로, 이를 확인하기 위해서는 스트림의 마지막 항목만 확인하면 됩니다:
~~~redis
> XREVRANGE race:france + - COUNT 1
1) 1) "1692632147973-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "29.9"
      5) "position"
      6) "1"
      7) "location_id"
      8) "2"
~~~

`XREVRANGE`는 시작 인자와 끝 인자를 반대로 받는 것에 주의하세요.

# Listening for new items with XREAD
***

만약 스트림 요소에 범위로 접근하고 싶지 않을 시, 구독을 통해 스트림에 들어오는 새로운 항목들을 받는 것이 일반적입니다.
이러한 컨셉은 채널을 구독하는 Redis Pub/Sub 방식이나, Redis 블로킹 리스트에서 키에 새로운 요소가 들어오기를 기다리는 
방식과 관련이 있어 보일 수 있지만, 스트림을 소비하는 방식에서 근본적인 차이가 있습니다:
1. 스트림은 데이터를 기다리는 여러 클라이언트를 가질 수 있습니다(소비자). 매 새로운 항목은 기본적으로 스트림을 구독하는
모든 소비작에게 전달됩니다. 이러한 특성은 각 소비자가 다른 항목을 받는 블로킹 리스트와 다릅니다. 하지만, 여러 클라이언트에게
팬아웃할 수 있는 접은 Redis Pub/Sub과 비슷합니다.
2. Pub/Sub 메시지들은 fire and forget 방식으로 작동되고 (영속적인 저장이 안된다는 뜻), 블로킹 리스트를 사용할 때는
클라이언트가 메시지를 수신하면 해당 메시지가 pop되어 리스트에서 제거됩니다. 하지만 스트림은 근본적으로 다른 방식으로 작동합니다.
모든 메시지는 스트림에 무기한으로 추가되며 (사용자가 명시적으로 삭제 요청을 하지 않는 한): 각 소비자는 마지막으로 수신한
메시지의 ID를 기억함으로써, 자신한테 어떤 메시지가 최신의 메시지인지 알 수 있습니다
3. 스트림 소비자 그룹은 Pub/Sub 또는 블로킹 리스트가 제공하지 않는 수준의 제어를 제공합니다. 같은 스트림에 대한 다른
그룹들을 둘 수 있으며, 처리된 항목에 대한 명시적 확인, 처리되지 않은 항목의 조회, 다른 소비자가 처리하지 못한 메시지에 대한 인수,
각 클라이언트별로 일관된 메시지 이력 가시성을 제공합니다 (각 클라이언트는 자신만의 과거 메시지만 볼 수 있음).

스트림에 도착하는 새로운 메시지들을 청취할 수 있게 해주는 명령어는 `XREAD`입니다. `XRANGE`에 비해서는 복잡하므로,
간단한 형식을 통해 먼저 살펴보고 전체를 보도록 하겠습니다.
~~~redis
> XREAD COUNT 2 STREAMS race:france 0
1) 1) "race:france"
   2) 1) 1) "1692632086370-0"
         2) 1) "rider"
            2) "Castilla"
            3) "speed"
            4) "30.2"
            5) "position"
            6) "1"
            7) "location_id"
            8) "1"
      2) 1) "1692632094485-0"
         2) 1) "rider"
            2) "Norem"
            3) "speed"
            4) "28.8"
            5) "position"
            6) "3"
            7) "location_id"
            8) "1"
~~~

위의 예시는 `XREAD`의 논-블로킹 형식입니다. **COUNT** 옵션은 필수가 아니며, **STREAMS** 옵션만 필수입니다.
**STREAMS** 옵션은 스트림 키 목록, 각 스트림에 대해 소비자가 본 최대 ID를 지정합니다. 해당 정보를 통해 
`XREAD`는 지정한 ID보다 큰 ID를 가진 메시지들만 클라이언트에게 제공하게 됩니다.

위의 명령에서 STREAMS race:france 0을 통해 `race:france` 스트림에서 ID가 0-0보다 큰 모든 메시지를 가져옵니다:
위의 예시에서 볼 수 있듯이 해당 명령어는 키 이름을 반환합니다. 키 이름을 반환하는 이유는 이 명령어를 통해 하나 이상의 키로
동시에 여러 스트림으로부터 호출하는 것이 가능하기 때문입니다. 예를 들어 다음과 같이 작성할 수도 있습니다: `STREAMS race: france 
race:italy 0 0`. STREAMS 옵션 뒤에는 키 이름들과 각 키에 대한 ID들을 제공해야 한다는 점에 주의하세요. 이러한 이유로,
STREAMS 옵션은 항상 마지막 옵션이 되어야 하고, 다른 옵션들은 STREAMS 옵션에 선행해서 작성되어야 합니다.

`XREAD`를 통해 여러 스트림에 한 번에 접근할 수 있다는 점과, 소유한 마지막 ID를 지정해 새로운 메시지를 받을 있다는 점을 제외하면,
이 단순한 형식의 명령어는 `XRANGE`와 크게 다를 점이 없습니다. 하지만, 흥미로운 점으 `XREAD`를 BLOCK 인자를 명시함으로써
블로킹 명령으로 쉽게 바꿀 수 있다는 것입니다.
~~~redis
> XREAD BLOCK 0 STREAMS race:france $
~~~

위의 예시에서 COUNT 옵션을 제거한 거 외에, BLOCK 옵션을 타임아웃 0 밀리초로 지정한 거에 주의하세요. 또한 mystream 스트림에
일반적인 ID 대신 특별한 ID인 `$`을 전달했습니다. 이 특별한 ID는 `XREAD`가 해당 mystream 스트림에 이미 저장된 가장 큰 ID를
마지막 ID로 사용하라는 의미이며, 청취를 시작한 시점부터 새 메시지만을 수신하게 됩니다. 이 명령은 Unix의 `tail -f` 명령과 유사합니다.

BLOCK 옵션이 사용되었을 경우 특별한 ID인 `$` 사용할 필요가 없습니다. 유효한 어떤 ID도 사용할 수 있습니다. 만약 명령어가 블로킹 없이
즉시 요청을 처리할 수 있다면, 처리될 것이고, 아니면 블로킹될 것입니다. 일반적으로 새로운 항목부터 스트림을 소비하고 싶다면, ID `$`로 시작한 다음
마지막으로 수신한 메시지의 ID를 사용하여 다음 호출을 계속 이어나가는 방식으로 진행됩니다.

`XREAD`의 블로킹 형태도 마찬가지로 여러 스트림을 여러 키 이름을 명시하는 방식으로 한 번에 수신할 수 있습니다. 우리가 지정한 ID보다 큰 요소가
적어도 하나의 스트림에 존재해서 요청을 즉시 처리할 수 있다면, 명령은 결과와 함께 즉시 반환됩니다. 그렇지 않으면 명령은 블로킹되고, 지정한 ID 
기준으로 가장 먼저 새 데이터를 받는 스트림의 항목을 반환하게 됩니다. 

블로킹 리스트 연산들처럼, 블로킹 스트림 조회는 FIFO로 동작하기 때문에 클라이언트의 시점에서 공정합니다. 특정 스트림에 대해 먼저 블로킹된
클라이언트가 새로운 항목이 도착했을 때 가장 먼저 블로킹이 해제됩니다.

`XREAD`는 COUNT와 BLOCK 외에는 다른 옵션들이 존재하지 않습니다. 즉, 소비자들을 하나 이상의 스트림에 연결시키는 간단한 명령어입니다.
스트림을 소비하는 더 강력한 기능들은 소비자 그룹 API를 통해 제공됩니다. 하지만, 소비자 그룹을 통해 조회하는 것은 `XREADGROUP`이라는 명령어로
구현되어 있고, 다음 섹션에서 소개할 예정입니다.

# Consumer Groups
***
동일한 스트림을 여러 클라이언트가 소비해야 하는 상황에서는 `XREAD`만으로도 N개의 클라이언트에게 fan-out이 가능합니다. 이때 읽기 확장성을 늘리기
위해 레플리카를 사용할 수도 있습니다. 하지만, 어떤 문제에서는 한 스트림안의 여러 메시지 부분집합들을 많은 클라이언트에게 제공하고 싶을 수 있습니다.
이러한 방식이 유용한 대표적인 경우는 처리가 오래 걸리는 메시지들입니다: 메시지들을 분할하여 N개의 다른 워커들에게 할당함으로써 메시지 처리 성능을
scale-out할 수 있습니다.

소비자 C1, C2, C3하고 메시지 1, 2, 3, 4, 5, 6, 7을 포함하는 스트림에서 다음과 같이 제공해야 한다고 가정해봅시다:
~~~redis
1 -> C1
2 -> C2
3 -> C3
4 -> C1
5 -> C2
6 -> C3
7 -> C1
~~~

이것을 이루기 위해서는, Redis는 소비자 그룹이라는 개념을 사용합니다. Redis의 소비자 그룹은 구현적인 관점에서 Kafka의 소비자 그룹과는
아무런 관련이 없습니다. 그래도 기능적으로는 유사하기 때문에 이를 대중화시킨 Kafka측의 용어를 그대로 사용하기로 했습니다.

소비자 그룹은 가상 소비자처럼 스트림으로부터 데이터를 수신하며, 여러 소비자들에게 데이터를 전달하는 역할을 하고 다음과 같은 내용들을 보장합니다:
1. 각 메시지는 다른 소비자에게 제공됩니다. 따라서 같은 메시지가 여러 소비자에게 전달되는 일은 없습니다.
2. 소비자 그룹내에서 소비자들은 이름으로 식별되며, 이는 대소문자를 구별하며 소비자를 구현하는 클라이언트가 반드시 선택해야 합니다. 이 말은 
연결이 끊긴 후에도, 스트림 소비자 그룹은 모든 상태를 유지해 클라이언트는 다시 연결할 때 자신이 동일한 소비자임을 주장할 수 있습니다. 하지만, 클라이언트에게는
고유한 식별자를 제공해야한다는 책임이 주어집니다.
3. 각 소비자 그룹은 아직 소비되지 않은 첫 번째 ID라는 개념을 가지고 있습니다. 이를 가지고 소비자가 새로운 메시지를 요청할 때 이전에 전달되지 않은 메시지들로만
제공할 수 있게 됩니다.
4. 메시지를 소비한 후에 특정한 명령어를 통해 명시적 확인이 필요합니다. Redis는 해당 확인을 다음과 같이 해석합니다: 이 메시지는 정상적으로 처리되었음으로
소비자 그룹에서 제거되어도 된다.
5. 소비자 그룹은 현재 대기중인 모든 메시지를 추적합니다. 대기중인 메시지란, 소비자 그룹의 어떤 소비자에게는 전달되었지만 아직 처리되었다고 확인되지 않은
메시지를 의미합니다. 해당 기능 덕분에 스트림 메시지 이력에 접근할 때 각 소비자는 자신에게 전달된 메시지만 볼 수 있게 됩니다.

어떤 면에서 보면, 소비자 그룹은 스트림에 대한 일정 상태를 유지하는 것으로 볼 수 있습니다:
~~~redis
+----------------------------------------+
| consumer_group_name: mygroup           |
| consumer_group_stream: somekey         |
| last_delivered_id: 1292309234234-92    |
|                                        |
| consumers:                             |
|    "consumer-1" with pending messages  |
|       1292309234234-4                  |
|       1292309234232-8                  |
|    "consumer-42" with pending messages |
|       ... (and so forth)               |
+----------------------------------------+
~~~

이 시점에서 이걸 보면, 소비자 그룹이 어떤 일을 하는지 쉽게 이해할 수 있습니다. 소비자 그룹은 각 소비자에게 미처리 메시지 이력을 제공할 수 있고,
소비자가 새로운 메시지를 요청하면 last_delivered_id보다 큰 메시지 ID들만 전달하면 됩니다. 동시에 소비자 그룹을 Redis 스트림을 위한 
보조 데이터 구조로 본다면, 동일한 스트림이 다른 소비자들로 이루어진 여러 소비자 그룹을 가질 수 있습니다. 실제로는 동일한 스트림에 대해
일부 클라이언트는 `XREAD`로 소비자 그룹없이 일고, 서로 다른 소비자 그룹에서 `XREADGROUP`을 통해 읽는 것도 가능합니다.

이제 소비자 그룹의 기본적인 명령어들을 살펴볼 때입니다. 다음과 같습니다:
- `XGROUP`은 소비자 그룹을 생성, 삭제, 관리하는데 사용됩니다.
- `XREADGROUP`은 소비자 그룹에서 스트림을 읽는 데 사용됩니다.
- `XACK`은 소비자가 미처리 메시지를 정상적으로 처리했음을 표시할 수 있게 해줍니다.

# Creating a consumer group
***

키 `race:france` 스트림이 이미 존재하고 새로운 소비자 그룹을 만든다고 가정해봅시다:
~~~redis
> XGROUP CREATE race:france france_riders $
OK
~~~

위의 명령에서 볼 수 있듯이 소비자 그룹을 생성할 때에는 ID를 명시해야 합니다(예시에서는 `$`). 이러한 이유는 소비자 그룹에은 생성되었을 때
처음 연결되는 소비자에게 어떤 메시지부터 제공할지를 결정할 상태 정보가 필요하기 때문입니다. 즉, 그룹이 생성되었을 때 마지막 메시지 ID가
무엇이었는지를 기준으로 삼습니다. 예제처럼 `$`을 전달하면, 이후 스트림에 도착하는 새로운 메시지들만 그룹의 소비자들에게 전달됩니다. 0을 사용할
경우, 스트림의 과거 모든 메시지를 처음부터 소비하게 됩니다. 물론, 다른 유효한 ID를 지정 가능합니다. 중요한 것은 주어진 ID보다 큰 메시지부터 
전달한다는 점입니다. `$`는 현재 스트림에서 가장 큰 ID를 의미하기 때문에, 이를 통해 새로운 메시지만 소비하는 효과를 가져갈 수 있습니다.

`XGROUP CREATE`는 스트림이 만약 존재하지 않으면 마지막 인자에 `MKSTREAM`을 추가해줌으로써 자동으로 생성해줍니다:
~~~redis
> XGROUP CREATE race:italy italy_riders $ MKSTREAM
OK
~~~

이제 소비자 그룹이 생성되었고, 소비자 그룹으로 `XREADGROUP`을 통해 즉시 메시지를 읽을 수 있습니다. 시스템이 소비자 Alice와 Bob에게 어떻게
다르게 메시지를 전달하는지를 확인해보겠습니다.

`XREADGROUP`은 `XREAD`와 매우 유사하며, 마찬가지로 BLOCK 옵션을 제공합니다. BLOCK 옵션이 없을 경우 동기 방식으로 작동합니다. 그러나 반드시
지정해야 할 필수적인 옵션이 있는데, 두 개의 인자를 가지는 GROUP입니다: 그룹의 이름, 조회를 시도하는 소비자의 이름을 받습니다. COUNT 옵션도
제공되며, `XREAD`의 COUNT와 동일합니다.

`race:italy` 스트림에 선수들을 추가하고, 소비자 그룹을 통해 어떤 것이든 읽어보겠습니다. 참고: 여기서 rider는 필드 이름이고, name은 
그에 해당하는 값입니다ㅏ. 스트림 요소들은 키-값 형태인 것을 기억하세요.
~~~redis
> XADD race:italy * rider Castilla
"1692632639151-0"
> XADD race:italy * rider Royce
"1692632647899-0"
> XADD race:italy * rider Sam-Bodden
"1692632662819-0"
> XADD race:italy * rider Prickett
"1692632670501-0"
> XADD race:italy * rider Norem
"1692632678249-0"
> XREADGROUP GROUP italy_riders Alice COUNT 1 STREAMS race:italy >
1) 1) "race:italy"
   2) 1) 1) "1692632639151-0"
         2) 1) "rider"
            2) "Castilla"
~~~

`XREADGROUP`은 `XREAD`와 같이 응답을 줍니다. 위의 `GROUP <group-name> <consumer-name>`을 확인하세요. 이것은 스트림을 소비자 그룹 mygroup과
소비자 Alice로 읽겠다고 하는 뜻입니다. 소비자가 소비자 그룹을 통해 작업을 할 때마다, 그룹안에서 식별되기 위해 반드시 이름을 명시해야 합니다.

위 명령어에서 또 하나의 중요한 점은 필수 옵션인 STREAMS 뒤에 mystream에 대해 요청한 ID가 특별한 ID `>`라는 점입니다. 소비자 그룹에서만 유효한
특별한 ID이며, **지금까지 어떤 소비자에게도 전달된 적이 없는 메시지들**을 요청한다는 뜻입니다.

이는 왠만한 요구사항들을 충족하지만, 0 또는 다른 유효한 ID처럼 실제 ID를 지정하는 것도 가능합니다. 이 경우에선느 `XREADGROUP`이 미처리 메시지들의
이력만 제공하며, 그룹 내 새로운 메시지들은 절대 수신되지 않습니다. `XREADGROUP`은 지정하는 ID에 따라 다음과 같은 동작을 합니다:
- 만약 ID가 `>`이면, 다른 소비자에게 전달된 적없는 메시지들만 반환하고, 소비자 그룹의 마지막 ID를 업데이트 합니다.
- ID가 다른 유효한 숫자형 ID인 경우, 이 명령어는 미처리 메시지들의 목록에 접근할 수 있게 해줍니다. 해당 소비자에게 전달되었지만 아직 `XACK`으로
처리 완료가 확인되지 않은 메시지들에 접근할 수 있게 해줍니다.

ID를 0으로 지정하고 COUNT 옵션을 사용하지 않으면 바로 테스트해볼 수 있습니다. 이 경우 Castilla 관련 미처리 메시지 하나만을 볼 수 있습니다.
~~~redis
> XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0
1) 1) "race:italy"
   2) 1) 1) "1692632639151-0"
         2) 1) "rider"
            2) "Castilla"
~~~

반면, 메시지가 처리되었음을 확인하면, 더 이상 미처리 메시지 이력에서 이를 확인할 수 없고, 시스템은 어떤 것도 반환하지 않을 것입니다.
~~~redis
> XACK race:italy italy_riders 1692632639151-0
(integer) 1
> XREADGROUP GROUP italy_riders Alice STREAMS race:italy 0
1) 1) "race:italy"
   2) (empty array)
~~~

`XACK`이 어떻게 동작하는지 몰라도 걱정하지 마세요. 더 이상 처리된 메시지는 확인할 수 없다는 뜻입니다.

이제는 Bob이 무엇인가를 읽어볼 차례입니다:
~~~redis
> XREADGROUP GROUP italy_riders Bob COUNT 2 STREAMS race:italy >
1) 1) "race:italy"
   2) 1) 1) "1692632647899-0"
         2) 1) "rider"
            2) "Royce"
      2) 1) "1692632662819-0"
         2) 1) "rider"
            2) "Sam-Bodden"
~~~

Bob은 최대 두 개의 메시지를 요청했고, 동일한 mygroup을 통해 메시지를 읽고 있습니다. 따라서 Redis는 새로운 메시지들만 보고합니다.
Castilla 메시지가 이미 Alice에게 전달되었기 때문에 Bob에게는 오지 않은 것을 확인할 수 있으며, 대신 Royce와 Sam-Bodden의 메시지만
받게 된 것입니다.

이러한 방식으로 Alice, Bob, 그리고 그룹 내의 다른 소비자들은 동일한 스트림에서 서로 다른 메시지를 읽을 수 있으며, 아직 처리하지 않은 메시지
이력을 조회하거나, 메시지를 처리 완료로 표시할 수도 있습니다. 이를 통해 스트림에서 메시지를 소비하는 방식에 대해 다양한 토폴로지와 시멘틱을
구성할 수 있스빈다.

다음은 주의할 몇 가지 점들입니다.
- 소비자들은 언급된 첫 번째 시점에 생성되므로 따로 명시적으로 생성할 필요가 없습니다.
- `XREADGROUP`으로도 여러 키를 한 번에 읽을 수 있습니다. 하지만, 이 작업을 위해서는, 모든 스트림에 같은 이름의 소비자 그룹을 생성해야 합니다.
일반적인 사례는 아니지만 기술적으로 가능하기에 언급했습니다.
- `XREADGROUP`은 쓰기 명령입니다. 그 이유는 스트림에서 읽는 것뿐만 아니라 소비자 그룹을 부수적으로 수정하기 때문에 마스터 인스턴스에서만 호출될 수 있습니다.

Ruby 언어로 소비자 그룹을 통해 소비자를 구현하는 방식은 다음과 같습니다. 이 코드는 Ruby를 몰라도 이해할 수 있을 정도로, 경험 있는 프로그래머라면 누구나
읽기 쉬운 형태로 구성되어 있습니다.
~~~ruby
require 'redis'

if ARGV.length == 0
    puts "Please specify a consumer name"
    exit 1
end

ConsumerName = ARGV[0]
GroupName = "mygroup"
r = Redis.new

def process_message(id,msg)
    puts "[#{ConsumerName}] #{id} = #{msg.inspect}"
end

$lastid = '0-0'

puts "Consumer #{ConsumerName} starting..."
check_backlog = true
while true
    # Pick the ID based on the iteration: the first time we want to
    # read our pending messages, in case we crashed and are recovering.
    # Once we consumed our history, we can start getting new messages.
    if check_backlog
        myid = $lastid
    else
        myid = '>'
    end

    items = r.xreadgroup('GROUP',GroupName,ConsumerName,'BLOCK','2000','COUNT','10','STREAMS',:my_stream_key,myid)

    if items == nil
        puts "Timeout!"
        next
    end

    # If we receive an empty reply, it means we were consuming our history
    # and that the history is now empty. Let's start to consume new messages.
    check_backlog = false if items[0][1].length == 0

    items[0][1].each{|i|
        id,fields = i

        # Process the message
        process_message(id,fields)

        # Acknowledge the message as processed
        r.xack(:my_stream_key,GroupName,id)

        $lastid = id
    }
end
~~~

보시다시피, 여기서의 아이디어는 자신에게 전달되었지만 아직 확인되지 않은 대기 중 메시지를 소비하는 것부터 시작합니다. 이 방식은
소비자가 이전에 다운됐을 시 재시작 할 때 ack없이 전달된 메시지를 다시 읽어 복구할 수 있기 때문에 유용합니다. 단, 이 과정에서
하나의 메시지가 중복으로 처리될 수도 있습니다 (이는 소비자 장애 시 불가피한 상황이며, Redis의 지속성과 복제의 한계도 영향을 줄 수 있습니다).
이와 관련되 내용은 이 가이드의 해당 섹션에서 다룰 예정입니다.

이력이 소비되면, 빈 배열의 메시지를 받게 되고 `>`을 통해 새로운 메시지를 소비할 수 있습니다.


# Recovering from permanent failures
***
위의 예시는 동일한 소비자 그룹에 참가하는 소비자들이 메시지들의 부분 집합을 처리할 수 있게 하며, 복구 시 자신한테 전달되었던 대기
중인 메시지들을 다시 읽을 수 있도록 해줍니다. 그러나 실제로는 소비자들이 영구적으로 실패하고 다시는 복구가 안될 수 있습니다.
그러면 중단된 소비자에게 전달된 미처리 메시지들은 어떻게 될까요?

Redis 소비자 그룹은 특정 소비자의 미처리 메시지들을 다른 소비자에게 할당할 수 있도록 하는 기능을 제공합니다. 해당 기능은
명시적으로 동작합니다. 소비자는 먼저 미처리 메시지들의 목록을 조회하고, 특별한 명령어를 통해 특정 메시지들을 claim해야 합니다.
그렇지 않으면, 서버는 메시지들을 평생 기존 소비자에게 할당된 채로 대기 중으로 냅둘 것입니다. 이러한 방식으로 다양한 애플리케이션들이
해당 기능에 대한 사용여부와 어떻게 사용할지를 정할 수 있습니다.

첫 번째 단계는 소비자 그룹 내의 미처리 메시지들에 대한 가시성을 제공해주는 `XPENDING` 명령어입니다. 읽기 전용 명령어이고,
어떤 메시지의 소유권도 바꾸지 않은 안전한 명령어입니다. 가장 간단한 형식으로 해당 명령어는 두 개의 인자로 호출됩니다.
두 개의 인자는 스트림의 이름과 소비자 그룹이 이름입니다.
~~~redis
> XPENDING race:italy italy_riders
1) (integer) 2
2) "1692632647899-0"
3) "1692632662819-0"
4) 1) 1) "Bob"
      2) "2"
~~~

이렇게 호출되었을때, 소비자 그룹의 미처리 메시지들의 수를 출력하고 (위의 예시의 경우 2개), 미처리 메시지들 중 가장 낮은 ID와 높은 ID, 
소비자들의 목록과 각각의 미처리 메시지들 수를 알려줍니다. Bob만이 두 개의 미처리 메시지들을 가지고 있습니다. Alice가
요청했던 메시지는 `XACK`를 통해 처리 완료되었기 때문입니다. 

`XPENDING`에 인자를 추가함으로서 더 많은 정보를 요청할 수 있습니다. 다음의 전체 명령어 형식입니다:
~~~redis
XPENDING <key> <groupname> [[IDLE <min-idle-time>] <start-id> <end-id> <count> [<consumer-name>]]
~~~

시작과 끝 ID(`XRANGE`에서 처럼 -, +로 사용 가능)와 반환되는 정보의 양을 제한하는 카운트 값을 함께 제공하면 미처리 메시지들에
대한 더 많은 정보를 확인할 수 있습니다. 선택적 마지막 인자로 소비자 이름을 지정하면, 주어진 소비자에 대한 미처리 메시지들만 출력할 수 
있습니다. 하지만, 아래의 예시에서는 해당 기능을 사용하지 않습니다.
~~~redis
> XPENDING race:italy italy_riders - + 10
1) 1) "1692632647899-0"
   2) "Bob"
   3) (integer) 74642
   4) (integer) 1
2) 1) "1692632662819-0"
   2) "Bob"
   3) (integer) 74642
   4) (integer) 1
~~~

이제 각 메시지에 대한 정보를 함께 볼 수 있습니다: ID, 소비자 이름, 유휴시간(밀리초, 메시지가 마지막으로 어떤 소비자에게 전달된 이후
경과한 시간), 전달횟수가 포함됩니다. Bob으로부터 두 개의 메시지가 있고, 1분 정도되는 60000+ 밀리초 정도 유휴되었습니다.

주의할 점은, `XRANGE` 명령어를 통해 첫 번째  메시지의 내용을 확인하는 것이 막혀있지 않다는 것입니다. 
~~~redis
> XRANGE race:italy 1692632647899-0 1692632647899-0
1) 1) "1692632647899-0"
   2) 1) "rider"
      2) "Royce"
~~~

같은 ID를 두번 인자로 반복하기만 하면 됩니다. Alice는 이제 1분 동안 메시지를 처리하지 않고 있는 Bob은 빠른 시일 내에
복구되지 않을 것이므로, 대신 처리하기 위해 `XCLAIM`을 통해 가져와야겠다고 판단했습니다.

이 명령어는 매우 복잡하고, 전체 형식에서는 매우 많은 옵션이 존재합니다. 그 이유는 이 명령어가 소비자 그룹의 변경의 복제하는데
사용되기 때문입니다. 일반적으로는 기본 인자로도 충분하면 다음과 같이 간단해집니다:
~~~redis
XCLAIM <key> <group> <consumer> <min-idle-time> <ID-1> <ID-2> ... <ID-N>
~~~

기본적으로 특정 키와 그룹에 대해 지정된 ID들의 소유권을 변경하고 특정 `<consumer>`에게 할당한다고 말한다. 그러나
최소 유휴 시간을 제공하는데, 언급된 메시지의 유휴 시간이 지정된 유휴 시간보다 클 때만 작동한다. 두 클라이언트가 동시에
같은 메시지를 가져오려고 시도할 수 있기 때문에 이는 유용합니다:
~~~redis
Client 1: XCLAIM race:italy italy_riders Alice 60000 1692632647899-0
Client 2: XCLAIM race:italy italy_riders Lora 60000 1692632647899-0
~~~

하지만, 부작용으로 메시지를 claim하는 것은 유휴 시간을 초기화시고, 전달 횟수 카운터를 증가시킵니다(deliveries counter).
그래서 두 번째 클라이언트는 claim에 실패하게 됩니다. 이러한 방식에서는 메시지의 불필요한 재처리를 방지할 수 있습니다.

다음은 명령을 실행한 결과입니다:
~~~redis
> XCLAIM race:italy italy_riders Alice 60000 1692632647899-0
1) 1) "1692632647899-0"
   2) 1) "rider"
      2) "Royce"
~~~

메시지는 Alice가 성공적으로 claim할 수 있었고, Alice는 이제 메시지를 처리하고 확인하는 것까지 가능합니다. 이로인해
원래의 소비자가 복구되지 못하더라도 계속 이어나갈 수 있습니다.

위의 예시에서 알 수 있듯이, 주어진 메시지를 claim하면 `XCLAIM` 명령어는 해당 메시지를 함께 반환합니다. 필수적인 것은
아닙니다. **JUSTID** 옵션을 통해 성공적으로 claim된 메시지들의 ID만 반환받을 수 있습니다. 이는 클라이언트와 서버 간의
대역폭 사용을 줄이고, 성능을 향상시키는데 유용합니다. 또한, 소비자가 주기적으로 미처리 메시지 이력을 검사하게 구현되어
있어 메시지 내용 자체에 관심 없는 경우에 특히 유용합니다.

Claming은 별도의 프로세스로 처리될 수 있습니다: 미처리 메시지들의 목록을 확인하고, 유휴 메시지들을 활성 소비자들에게
할당할 수 있습니다. 활성 소비자들은 Redis 스트림의 관측 기능 중 하나를 확인해 사용할 수 있습니다. 이는 다음 섹션에서 다루겠습니다.

# Automatic claiming
***
`XAUTOCLAIM` 명령어는 Redis 6.2에서 추가되었습니다. 위에서 설명한 claiming 절차를 바탕으로 구현되었습니다.
`XPENDING`하고 `XCLAIM`은 다양한 복구 메커니즘을 구성하기 위한 기본적인 빌딩 블록을 제공합니다. `XAUTOCLAIM`은
이러한 일반적인 과정을 Redis가 관리하게 최적화하여, 대부분의 복구에 간단한 해결책을 제공합니다.

`XAUTOCLAIM`은 유휴 미처리 메시지들을 식별하며, 메시지들의 소유권을 소비자에게 전달합니다. 명령어의 시그니처는 다음과
같습니다:
~~~redis
XAUTOCLAIM <key> <group> <consumer> <min-idle-time> <start> [COUNT count] [JUSTID]
~~~

위의 예시에서처럼, 자동 claiming 기능을 사용하여 단일 메시지를 claim하려면 다음과 같이 할 수 있습니다:
~~~redis
> XAUTOCLAIM race:italy italy_riders Alice 60000 0-0 COUNT 1
1) "0-0"
2) 1) 1) "1692632662819-0"
      2) 1) "rider"
         2) "Sam-Bodden"
~~~

`XCLAIM`처럼 명령어는 claimed된 메시지들의 배열과 미처리 항목들을 순회할 수 있게 해주는 스트림 ID를 같이 반환합니다.
스트림 ID는 커서로서 다음 호출 때 이를 통해 미처리 메시지들을 claiming할 수 있습니다:
~~~redis
> XAUTOCLAIM race:italy italy_riders Lora 60000 (1692632662819-0 COUNT 1
1) "1692632662819-0"
2) 1) 1) "1692632647899-0"
      2) 1) "rider"
         2) "Royce"
~~~

`XAUTOCLAIM`이 스트림 ID "0-0"을 커서로서 반환하면, 소비자 그룹의 미처리 항목의 끝에 도달했다는 뜻입니다.
유휴 메시지가 더 이상 존재하지 않다는 뜻이며, 따라서 프로세스는 스트림의 시작 지점부터 다시 `AUTOCLAIM`을 호출하여
진행해야 합니다