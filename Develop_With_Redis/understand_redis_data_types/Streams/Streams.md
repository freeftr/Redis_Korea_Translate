# Redis Streams
Redis Streams에 대한 소개

Redis Stream은 append-only 로그같은 방식으로 동작하는 자료 구조입니다. 하지만, 일반적인 append-only 로그의 한계를
극복할 수 있는 여러 연산을 제공합니다. 시간복잡도 O(1)의 랜덤 액세스와 소비자 그룹같은 복잡한 소비 전략등이 포함됩니다.
Streams를 통해 이벤트를 실시간으로 기록하고 동시에 배포할 수 있습니다. 다음은 Redis Stream의 사용사례입니다:

- 이벤트 소싱 (예: 사용자 행동, 클릭)
- 센서 모니터링 (예: 장비들 감시)
- 알림 (예: 별개의 스트림에 각 사용자의 알림 저장)

Redis는 각 스트림 항목에 대해 고유한 ID를 생성합니다. 이 ID를 가지고 관련 항목을 조회하거나, 스트림 내에서
이후의 항목들을 읽거나 처리할 수 있습니다. 이 ID들은 시간에 관계되어 있기 때문에, 이 문서에 표시된 ID는 실제 Redis 
인스턴스에서 보게 되는 ID와 다를 수 있습니다.

Redis 스트림은 여러 트리밍 전략(스트림이 무한으로 늘어나는 것을 방지하기 위함)과 여러가지 소비 전략을 지원합니다.(
`XREAD`, `XREADGROUP`, `XRANGE`를 확인해보세요.)

## Basic commands
***
- `XADD`는 새 항목을 스트림에 추가합니다.
- `XREAD`는 지정된 위치에서 시간 순으로 앞으로 이동하면서 하나 이상의 항목을 읽습니다.
- `XRANGE`는 두 개의 입력된 항목 ID 사이의 항목들의 범위를 반환합니다.
- `XLEN`은 스트림의 길이를 반환합니다.

다음 링크에서 스트림 명령어들의 전체 목록을 확인하세요.
- https://redis.io/docs/latest/commands/?group=stream

# Examples
***
- 선수들이 체크포인트를 지날 때마다, 각 선수에 대한 정보(이름, 속도, 위치, 장소 ID)를 기록한 스트림 항목을 추가합니다:
~~~redis
> XADD race:france * rider Castilla speed 30.2 position 1 location_id 1
"1692632086370-0"
> XADD race:france * rider Norem speed 28.8 position 3 location_id 1
"1692632094485-0"
> XADD race:france * rider Prickett speed 29.7 position 2 location_id 1
"1692632102976-0"
~~~

- ID 1692632086370-0에서 시작하는 두 스트림 항목들을 읽습니다:
~~~redis
> XRANGE race:france 1692632086370-0 + COUNT 2
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
2) 1) "1692632094485-0"
   2) 1) "rider"
      2) "Norem"
      3) "speed"
      4) "28.8"
      5) "position"
      6) "3"
      7) "location_id"
      8) "1"
~~~

- 스트림 끝에서 시작하여 최대 100개의 새 스트림 항목을 읽고, 항목이 쓰여지지 않으면 최대 300밀리초 동안 대기하려면
다음과 같습니다:
~~~redis
> XREAD COUNT 100 BLOCK 300 STREAMS race:france $
(nil)
~~~

## Performance
***

스트림에 새로운 항목을 추가하는 작업은 시간복잡도 O(1)입니다. 단일 항목에 대한 접근 시간복잡도 O(n)이고, 여기서
n은 ID의 길이입니다. 스트림 ID는 보통 짧고 고정된 길이를 가지기 때문에, 보통 상수 시간에 처리됩니다. 그 이유에 대해
알고 싶다면 스트림은 **radix trees**로 구현되어 있다는 것을 참고하면 됩니다.
- https://en.wikipedia.org/wiki/Radix_tree
> Radix Tree
Radix 트리는 압축된 Trie 구조라고 볼 수 있다. Trie 구조에서는 한 글자씩 노드에 할당하지만, Radix 트리는 
여러 문자를 한 노드에 저장해 압축한다.
DNS 룩업, 라우팅 테이블등에 사용이 된다.

간단히 말해서, Redis 스트림은 매우 효율적인 삽입과 읽기 성능을 가졌습니다. 시간 복잡도에 대한 내용은
각 명령어 페이지에서 확인할 수 있습니다.

## Stream basics
***
스트림은 append-only 자료구조입니다. 기본적인 쓰기 명령어인 `XADD`는 특정한 스트림에 새로운 항목을 추가합니다.

각 스트림 항목은 하나 이상의 키-값 쌍들을 가지며, 이는 dictionary 또는 Redis 해시와 비슷합니다:
~~~redis
> XADD race:france * rider Castilla speed 29.9
position 1 location_id 2
"1692632147973-0"
~~~

위의 `XADD` 호출은 ` rider: Castilla, speed: 29.9, position: 1, location_id: 2`을 `race:france` 스트림에
추가됩니다. 이때 1692632147973-0라는 자동 생성된 항목 ID를 반환합니다. 첫 번째 인자는 키의 이름이고, 두 번째 인자는 
스트림 내의 각 항목을 식별하는 ID입니다. 하지만, 이 사례에서는 *를 사용했기 때문에 Redis 서버가 자동으로 새로운 ID를
생성해줍니다. 모든 새로운 ID는 단조적으로 증가합니다. 쉽게 바꿔 말하면, 모든 새로운 항목은 기존의 항목들과 비교해서 항상
큰 ID 값을 가질 것입니다. ID를 서버가 자동으로 생성하는 방식이 거의 항상 바람직하며, 명시적으로 ID를 지정해야 하는 경우는 
매우 드뭅니다. 이에 대해서는 이후에 더 설명합니다. 각 스트림 항목이 ID를 가지고 있다는 점은 로그와 비슷하며, 로그에서는
행 번호나 바이트 오프셋을 통해 항목을 식별할 수 있는 것처럼 말입니다. `XADD` 예시로 돌아와서, 키 이름과 ID 뒤에는
스트림 항목을 구성하는 키-값들이 인자로 들어옵니다.

`XLEN`을 통해 스트림 안의 항목들의 개수를 조회할 수 있습니다:
~~~redis
> XLEN race:france
(integer) 4
~~~

### Entry IDs
`XADD`로 반환받은 항목 ID는 스트림 내에서 각 항목을 고유하게 식별하며, 두 부분으로 구성됩니다:
~~~redis
<millisecondsTime>-<sequenceNumber>
~~~

밀리초 부분은 스트림 ID를 생성하는 Redis 노드의 로컬 시간입니다. 하지만 만약 현재 밀리초 시간이 이전의 항목 시간보다
작으면 이전 항목 시간을 사용이 대신 사용됩니다. 이는 시스템 시계가 되돌아가는 일이 발생해도 ID를 단조적으로 증가시키는 것을
유지시키기 위해서 입니다. 시퀸스 번호는 같은 밀리초 내에서 생성된 항목들에 대해 사용됩니다. 이 시퀸스 번호는 64 비트
정수이기 때문에, 현실적으로는 같은 밀리초 안에서 생성할 수 있는 항목 수에 제한이 없습니다.

이러한 형식의 ID는 처음에는 이상해 보일 수 있지만, ID에 시간이 들어간 이유가 있습니다. 그 이유는 Redis 스트림은
ID로 범위 질의를 지원하기 때문입니다. ID가 항목이 생성된 시간에 관계되어 있기 때문에, 시간을 가지고 질의를 할 수 있습니다.
이것에 대해 추후 `XRANGE` 명령어를 살펴보면서 더 살펴보겠습니다.

여러 이유로 시간과 관련되지 않고, 실제로는 외부 시스템의 다른 ID와 연관된 증가하는 ID가 필요하다면, 앞서 언급했듯이
`XADD` 명령은 자동 생성을 트리거하는 * 와일드카드 ID 대신 명시적으로 ID를 생성할 수 있습니다. 다음의 예시에서
보겠습니다:
~~~redis
> XADD race:usa 0-1 racer Castilla
0-1
> XADD race:usa 0-2 racer Norem
0-2
~~~

이 사례에서는 최소 ID 0-1임을 주의하세요. 이전에 사용된 ID보다 작거나 동일한 ID는 허용되지 않습니다:
~~~redis
> XADD race:usa 0-1 racer Prickett
(error) ERR The ID specified in XADD is equal or smaller than the target stream top item
~~~

만약 Redis 7 버전 이후를 사용하신다면, 밀리초 시간 부분만 포함된 명시적 ID를 제공할 수도 있습니다. 이 경우
시퀸스 번호 부분은 자동으로 생성됩니다. 다음과 같은 문법으로 사용할 수 있습니다:
~~~redis
> XADD race:usa 0-* racer Prickett
0-3
~~~

# Getting data from Streams
***

이제 우리는 스트림에 `XADD`를 이용하여 항목들을 추가할 수 있습니다. 하지만, 스트림에 데이터를 추가하는 것은 이제
명확하지만, 스트림에서 질의를 통해 데이터를 추출하는 것은 아직입니다. 로그 파일에 대한 비유를 계속하자면,
한 가지 명백한 방법은 우리가 일반적으로 Unix 명령어 `tail -f`로 하는 작업을 흉내 내는 것입니다. 즉, 스트림에 새로 추가되는
메시지를 얻기 위해 감시할 수 있습니다. 주의할 점은, Redis의 블로킹 리스트 연산들에서는 특정 요소가 pop과 같은 연산으로
블로킹 중인 하나의 클라이언트에게만 전달되는 반면, 스트림에서는 새로 추가된 메시지를 여러 소비자들이 볼 수 있기를 원한다는
점입니다. 스트림이 메시지를 여러 클라이언트에게 팬아웃할 수 있기를 원하는 것입니다.

하지만, 이것은 단지 하나의 접근 방법일 뿐입니다. 다른 방식으로 스트림을 볼 수 있습니다: 메시징 시스템이 아닌, 시계열 
저장소로 말이죠. 이 사례에서도 새로 추가된 메시지를 수신하는 것은 용이하지만, 또 다른 자연스러운 쿼리 방식은 시간 범위에
따라 메시지를 조회하거나, 커서를 사용하여 전체 이력을 점진적으로 확인하는 방식입니다. 이는 또 다른 유용한 접근 방식입니다.

마지막으로, 스트림을 소비자의 관점에서 바라본다면, 스트림에 접근하는 다른 방식이 필요할 수 있습니다. 스트림의 메시지들을
파티셔닝하여 여러 소비자에게 분할하여 처리하는 방식입니다. 소비자 그룹은 스트림에 도착하는 일부 메시지만 볼 수 있으며,
이러한 방식에서는 여러 다른 소비자들에게 메시지 처리를 분산시켜 확장성을 가져갈 수 있습니다: 각 소바자들은 처리해야할 
다른 메시지들을 받게됩니다. 이 방식은 Kafka(TM)가 소비자 그룹을 관리하는 것과 동일합니다. 소비자 그룹을 통해 메시지를
읽는 것은 Redis 스트림의 또 하나의 흥미로운 기능입니다.

Redis 스트림은 위에서 설명한 세 가지 쿼리 모드를 서로 다른 명령어를 통해 지원합니다. 다음 섹션에서 모두 소개할 것이며, 
가장 간단하고 직관적인 것부터 시작하겠습니다: **범위 질의**

## Querying by range: XRANGE and XREVRANGE
스트림을 범위 질의하려면 시작 ID와 끝 ID만 필요합니다. 질의를 통해 반환되는 범위에는 시작과 끝 ID가 포함됩니다. 따라서
해당 범위는 포함 범위입니다. 특수한 두 ID -와 +는 각각 가장 작은 ID와 가장 큰 ID를 의미합니다.
~~~redis
> XRANGE race:france - +
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
2) 1) "1692632094485-0"
   2) 1) "rider"
      2) "Norem"
      3) "speed"
      4) "28.8"
      5) "position"
      6) "3"
      7) "location_id"
      8) "1"
3) 1) "1692632102976-0"
   2) 1) "rider"
      2) "Prickett"
      3) "speed"
      4) "29.7"
      5) "position"
      6) "2"
      7) "location_id"
      8) "1"
4) 1) "1692632147973-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "29.9"
      5) "position"
      6) "1"
      7) "location_id"
      8) "2"
~~~

반환받은 각 항목은 두 아이템의 배열입니다: ID와 키-값 쌍들의 리스트입니다. 이전에 언급했듯이 항목 ID는 시간과 관게가 있으며,
ID의 '-' 문자 왼쪽에 있는 스트림 항목이 생성된 시점의 로컬 노드의 Unix 밀리초 시간입니다 (스트림은 `XADD` 명령을
명시적 복제하기 때문에, 복제본에서도 마스터와 동일한 ID를 갖게 됨에 주의하세요). 이것은 `XRANGE`를 통해 
시간을 범위로 질의할 수 있다는 것을 의미합니다. 이를 위해서 ID의 시퀸스 부분을 생략할 수도 있습니다: 범위의 시작 ID에서
생략되면 0으로 간주되고, 끝 부분에서 생략되면 가능한 최대의 시퀸스 번호로 간주됩니다. 이 방식으로 두 Unix 밀리초 시간 사이에서
생성된 모든 항목들을 가져올 수 있습니다(포함 범위로). 예시로, 2 밀리초 동안을 질의하고 싶으면 다음과 같이 할 수 있습니다:
~~~redis
> XRANGE race:france 1692632086369 1692632086371
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
~~~

해당 범위에서는 하나의 항목밖에 존재합니다. 하지만, 실제 데이터셋에서는 수 시간으로 질의할 수 있으며, 2 밀리초 안에 
수많은 요소들이 들어있어 결과가 방대할 수 있습니다. 이러한 이유로, `XRANGE`는 끝에 **COUNT** 옵션을 제공합니다.
개수를 명시하는 방식으로 첫 N개의 항목들만 가져올 수 있습니다. 만약 더 원하면, 마지막으로 반환된 ID를 1 증가시켜서 
다시 질의하면 됩니다. 다음의 예시에서 살펴봅시다. `race:france` 스트림에 4개 항목이 있다고 가정해 봅시다. 반복을
시작하기 위해서 전체 범위를 질의하되, count 2로 2개의 요소만 가져오겠습니다.
~~~redis
> XRANGE race:france - + COUNT 2
1) 1) "1692632086370-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "30.2"
      5) "position"
      6) "1"
      7) "location_id"
      8) "1"
2) 1) "1692632094485-0"
   2) 1) "rider"
      2) "Norem"
      3) "speed"
      4) "28.8"
      5) "position"
      6) "3"
      7) "location_id"
      8) "1"
~~~

다음 두 요소를 조회하기 위해서 반환받은 마지막 ID(1692632094485-0)에 접두사 '('를 붙입니다. 이렇게 하면
(1692632094485-0 이라는 배타적 범위(exclusive range)가 되고 해당 값을 다음 `XRANGE`에 사용할 수 있습니다:
~~~redis
> XRANGE race:france (1692632094485-0 + COUNT 2
1) 1) "1692632102976-0"
   2) 1) "rider"
      2) "Prickett"
      3) "speed"
      4) "29.7"
      5) "position"
      6) "2"
      7) "location_id"
      8) "1"
2) 1) "1692632147973-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "29.9"
      5) "position"
      6) "1"
      7) "location_id"
      8) "2"
~~~

이제 4개의 요소가 들어있는 스트림에서 4개 모두 조회하였으며, 추가적으로 더 조회할 경우 빈 배열을 반환받게 됩니다:
~~~redis
> XRANGE race:france (1692632147973-0 + COUNT 2
(empty array)
~~~

`XREVRANGE`는 `XRANGE`의 반환 값을 거꾸로 받는 것이므로, 이를 확인하기 위해서는 스트림의 마지막 항목만 확인하면 됩니다:
~~~redis
> XREVRANGE race:france + - COUNT 1
1) 1) "1692632147973-0"
   2) 1) "rider"
      2) "Castilla"
      3) "speed"
      4) "29.9"
      5) "position"
      6) "1"
      7) "location_id"
      8) "2"
~~~

`XREVRANGE`는 시작 인자와 끝 인자를 반대로 받는 것에 주의하세요.

# Listening for new items with XREAD
***

만약 스트림 요소에 범위로 접근하고 싶지 않을 시, 구독을 통해 스트림에 들어오는 새로운 항목들을 받는 것이 일반적입니다.
이러한 컨셉은 채널을 구독하는 Redis Pub/Sub 방식이나, Redis 블로킹 리스트에서 키에 새로운 요소가 들어오기를 기다리는 
방식과 관련이 있어 보일 수 있지만, 스트림을 소비하는 방식에서 근본적인 차이가 있습니다:
1. 스트림은 데이터를 기다리는 여러 클라이언트를 가질 수 있습니다(소비자). 매 새로운 항목은 기본적으로 스트림을 구독하는
모든 소비작에게 전달됩니다. 이러한 특성은 각 소비자가 다른 항목을 받는 블로킹 리스트와 다릅니다. 하지만, 여러 클라이언트에게
팬아웃할 수 있는 접은 Redis Pub/Sub과 비슷합니다.
2. Pub/Sub 메시지들은 fire and forget 방식으로 작동되고 (영속적인 저장이 안된다는 뜻), 블로킹 리스트를 사용할 때는
클라이언트가 메시지를 수신하면 해당 메시지가 pop되어 리스트에서 제거됩니다. 하지만 스트림은 근본적으로 다른 방식으로 작동합니다.
모든 메시지는 스트림에 무기한으로 추가되며 (사용자가 명시적으로 삭제 요청을 하지 않는 한): 각 소비자는 마지막으로 수신한
메시지의 ID를 기억함으로써, 자신한테 어떤 메시지가 최신의 메시지인지 알 수 있습니다
3. 스트림 소비자 그룹은 Pub/Sub 또는 블로킹 리스트가 제공하지 않는 수준의 제어를 제공합니다. 같은 스트림에 대한 다른
그룹들을 둘 수 있으며, 처리된 항목에 대한 명시적 확인, 처리되지 않은 항목의 조회, 다른 소비자가 처리하지 못한 메시지에 대한 인수,
각 클라이언트별로 일관된 메시지 이력 가시성을 제공합니다 (각 클라이언트는 자신만의 과거 메시지만 볼 수 있음).

스트림에 도착하는 새로운 메시지들을 청취할 수 있게 해주는 명령어는 `XREAD`입니다. `XRANGE`에 비해서는 복잡하므로,
간단한 형식을 통해 먼저 살펴보고 전체를 보도록 하겠습니다.
~~~redis
> XREAD COUNT 2 STREAMS race:france 0
1) 1) "race:france"
   2) 1) 1) "1692632086370-0"
         2) 1) "rider"
            2) "Castilla"
            3) "speed"
            4) "30.2"
            5) "position"
            6) "1"
            7) "location_id"
            8) "1"
      2) 1) "1692632094485-0"
         2) 1) "rider"
            2) "Norem"
            3) "speed"
            4) "28.8"
            5) "position"
            6) "3"
            7) "location_id"
            8) "1"
~~~

위의 예시는 `XREAD`의 논-블로킹 형식입니다. **COUNT** 옵션은 필수가 아니며, **STREAMS** 옵션만 필수입니다.
**STREAMS** 옵션은 스트림 키 목록, 각 스트림에 대해 소비자가 본 최대 ID를 지정합니다. 해당 정보를 통해 
`XREAD`는 지정한 ID보다 큰 ID를 가진 메시지들만 클라이언트에게 제공하게 됩니다.

