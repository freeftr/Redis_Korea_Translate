# Redis keyspace notifications
Redis 키-값 변경 실시간 모니터링

Keyspace notifications는 클라이언트가 Redis 데이터 집합에 영향을 주는 이벤트들을 수신할 수 있게
Pub/Sub 채널들을 구독할 수 있게 해줍니다. 

수신받는 이벤트들의 예시는 다음과 같습니다:
- 주어진 키에 영향을 주는 모든 명령어들.
- LPUSH 연산을 받는 모든 키들.
- 데이터베이스 0에서 만료되는 모든 키들.

참고: Redis Pub/Sub은 fire and forget 방식입니다: 만약 Pub/Sub 클라이언트가 연결을 끊고 잠시 후 재연결하면, 클라이언트가
연결이 끊어진 동안 전송된 모든 이벤트들은 유실됩니다.

## Type of Events

Keyspace notifications는 Redis 데이터 공간에 영향을 주는 모든 연산에 대해 두 개의 별개의 유형의 이벤트들을 전송함으로서 구현됩니다.
예를 들어, 데이터베이스 0에 있는 "mykey"라는 키에 대상으로 하는 `DEL` 연산은 다음의 두 개`PUBLISH` 명령어와 동일한 두 개의 메시지를
트리거합니다.

~~~redis
PUBLISH __keyspace@0__:mykey del
PUBLISH __keyevent@0__:del mykey
~~~

첫 번째 채널은 "mykey"를 대상으로 하는 모든 이벤트들을 수신하고, 다른 채널은 "mykey"에 대한 `DEL` 연산만을 감시합니다.

채널에 keyspace 접두사가 붙은 첫 번째 유형은 **Key-space notification**이라고 불리고, keyevent 접두사가 붙은 두 번째 유형은
**Key-event notification**이라고 불립니다.

이전의 예시에서 "mykey"에 대한 `DEL` 이벤트가 생성되었고, 두 메시지가 전송됩니다:
- Key-space 채널은 이벤트의 이름을 메시지로서 수신합니다.
- Key-event 채널은 키의 이름을 메시지로 수신합니다.

관심있는 하나의 유형의 알림만 활성화시키는 것도 가능합니다.

## Configuration

기본적으로 Keyspace 이벤트 알림은 비활성화되어 있습니다. CPU 자원을 사용하지만, 민감한 정보는 아니기 때문입니다. 알림은
redis.conf 파일의 notify-keyspace-event 설정이나 `CONFIG SET` 명령을 통해 활성화할 수 있습니다.

이 매개변수를 빈 문자열로 설정하면 알림이 비활성활수 있습니다. 해당 기능을 활성화시키려면 비어있지 않는 문자열을 사용해야 하며, 다음 테이블에 따라
특별한 의미를 가지는 여러 문자로 구성되어야 합니다:

~~~redis
K   Keyspace events, published with __keyspace@<db>__ prefix.
    - Keyspace 이벤트, __keyspace@<db>__ 접두사로 발행
E   Keyevent events, published with __keyevent@<db>__ prefix.
    - Keyevent 이벤트, __keyevent@<db>__ 접두사로 발행
g   Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
    - 일반적인 명령어 (특정 타입에 국한되지 않는) ex) DEL, EXPIRE, RENAME, ...
$   String commands
    - 문자열 명령어
l   List commands
    - 리스트 명령어
s   Set commands
    - Set 명령어
h   Hash commands
    - 해시 명령어
z   Sorted set commands
    - Sorted set 명령어
t   Stream commands
    - 스트림 명령어
d   Module key type events
    - 모듈 키 타입 이벤트
x   Expired events (events generated every time a key expires)
    - 키가 만료될 때 마다 생성되는 이벤트
e   Evicted events (events generated when a key is evicted for maxmeory)
    - maxmemory 정책에 의해 키가 제거될 때 마다 생성되는 이벤트
m   Key miss events (events generated when a key that doesn't exist is accessed)
    - 존재하지 않는 키에 대한 접근 실패 이벤트
n   New key events (Note: not included in the 'A' class)
    - 새로운 키 생성 이벤트 (아래의 A 그룹에는 포함되지 않음)
A   Alias for "g$lshztxed", so that the "AKE" String means all the events except "m" and "n".
    - "g$lshztxed"의 별칭으로, "AKE"는 "m"과 "n"을 제외한 모든 이벤트를 의미함
~~~

K나 E 중 하나는 반드시 문자열에 있어야 하며, 문자열의 나머지 부분과 상관없이 어떤 이벤트도 전송되지 않을 것입니다.

예를 들어 list를 위한 Key-space 이벤트만 활성화 시키려면, 설정 파라미터를 Kl로 지정해야 합니다.

문자열 "KEA"를 통해 대부분의 유형의 이벤트들을 활성화시킬 수 있습니다.

## Events generated by different commands

다음 목록에 따라 명령어마다 서로 다른 종류의 이벤트를 생성합니다.

- `APPEND`는 append 이벤트를 생성합니다.
- `COPY`는 copy_to 이벤트를 생성합니다.
- `DEL`은 키가 삭제될때마다 del 이벤트를 생성합니다.
- `EXPIRE`과 변형들 (`PEXPIRE`, `EXPIREAT`, `PEXPIREAT`)은 양수 타임아웃이나 미래 시점의 타임스탬프로 호출되면 expire 이벤트를 생성합니다.
  - 참고: 음수 타임아웃이나 과거 시점 타임스탬프가 호출되면 키는 삭제되면 del 이벤트를 생성하게 됩니다.
- `HDEL`은 hdel 이벤트 하나를 생성하고, 해시가 비어 키가 제거되면 추가적으로 del 이벤트도 생성합니다.
- `HEXPIRE`과 변형들 (`HPEXPIRE`, `HEXPIREAT`, `HPEXPIREAT`)은 hexpire 이벤트를 생성합니다. 필드가 만료될 경우 hexpired 이벤트를 생성합니다.
- `HINCRBYFLOAT`는 hincrbyfloat 이벤트를 생성합니다.
- `HINCRBY`는 hincrby 이벤트를 생성합니다.
- `HPERSIST`는 hpersist 이벤트를 생성합니다. 
- `HSET`, `HSETNX`, `HMSET`은 모두 hset 이벤트 하나를 생성합니다.
- `INCRBYFLOAT`는 incrbyfloat 이벤트를 생성합니다.
- `INCR`, `DECR`, `INCRBY`, `DECRBY`는 모두 incrby 이벤트를 생성합니다.
- `LINSERT`는 linsert 이벤트를 생성합니다.
- `LMOVE`, `BLMOVE`는 lpop 또는 rpop 이벤트(출발 방향에 따라 다름)와 lpush 또는 rpush 이벤트(도착 방향에 따라 다름)를 생성합니다.
두 이벤트의 순서는 보장되며, 항상 lpop/rpop이 먼저 발생하고 lpush/rpush가 나중입니다. 결과 리스트 길이가 0이 되어 키가 제거되면 del 이벤트도 생성됩니다.
- `LPOP`은 lpop 이벤트를 생성하며, 리스트의 마지막 요소가 제거되어 키가 사라지면 추가로 del 이벤트도 생성됩니다.
- `LPUSH`, LPUSHX는 (여러 인자가 있어도) lpush 이벤트 하나만 생성합니다.
- `LREM`은 lrem 이벤트와 함께, 리스트가 비어 키가 제거되면 추가로 del 이벤트도 생성됩니다.
- `LSET`은 lset 이벤트를 생성합니다.
- `LTRIM`은 ltrim 이벤트를 생성하고, 결과 리스트가 비어 키가 제거되면 del 이벤트도 생성됩니다.
- `MIGRATE`는 소스 키가 제거되면 del 이벤트를 생성합니다.
- `MOVE`는 소스 키에 대해 move_from, 대상 키에 대해 move_to 이벤트를 생성합니다.
- `MSET`은 키마다 각각 set 이벤트를 생성합니다.
- `PERSIST`는 키의 만료 시간이 삭제되었을 때 persist 이벤트를 생성합니다.
- `RENAME`은 소스 키에 대해 rename_from, 대상 키에 대해 rename_to 이벤트를 생성합니다.
- `RESTORE`는 해당 키에 대해 restore 이벤트를 생성합니다.
- `RPOPLPUSH`, `BRPOPLPUSH`는 rpop 이벤트 후 lpush 이벤트를 생성하며, 리스트가 비어 키가 제거되면 del 이벤트도 생성됩니다.
- `RPOP`은 rpop 이벤트를 생성하며, 마지막 요소 제거로 키가 사라지면 del 이벤트도 생성됩니다.
- `RPUSH`, `RPUSHX`는 (여러 인자가 있어도) rpush 이벤트 하나를 생성합니다.
- `SADD`는 (여러 인자가 있어도) sadd 이벤트 하나를 생성합니다.
- `SETRANGE`는 setrange 이벤트를 생성합니다.
- `SET` 및 변형들(`SETEX`, `SETNX`, `ETSET`)은 set 이벤트를 생성합니다. 단, SETEX는 set과 함께 expire 이벤트도 생성합니다.
- `SINTERSTORE`, `SUNIONSTORE`, `SDIFFSTORE`는 각각 sinterstore, sunionstore, sdiffstore 이벤트를 생성합니다. 결과 집합이 비고 기존 키가 존재했다면, 해당 키가 삭제되어 del 이벤트도 생성됩니다.
- `SMOVE`는 소스 키에 대해 srem, 대상 키에 대해 sadd 이벤트를 생성합니다.
- `SORT`는 STORE 옵션이 사용될 경우 sortstore 이벤트를 생성합니다. 결과 리스트가 비고 기존 키가 존재했다면, 해당 키 삭제로 del 이벤트도 발생합니다.
- `SPOP`은 spop 이벤트를 생성하고, 결과 셋이 비어 키가 제거되면 del 이벤트도 생성됩니다.
- `SREM`은 srem 이벤트를 생성하며, 셋이 비어 키가 제거되면 del 이벤트도 생성됩니다.
- `XADD`는 xadd 이벤트를 생성하며, MAXLEN 서브커맨드 사용 시 xtrim 이벤트도 발생할 수 있습니다.
- `XDEL`은 여러 항목을 삭제해도 xdel 이벤트 하나만 생성합니다.
- `XGROUP CREATECONSUMER`는 xgroup-createconsumer 이벤트를 생성합니다.
- `XGROUP CREATE`는 xgroup-create 이벤트를 생성합니다.
- `XGROUP DELCONSUMER`는 xgroup-delconsumer 이벤트를 생성합니다.
- `XGROUP DESTROY`는 xgroup-destroy 이벤트를 생성합니다.
- `XGROUP SETID`는 xgroup-setid 이벤트를 생성합니다.
- `XSETID`는 xsetid 이벤트를 생성합니다.
- `XTRIM`은 xtrim 이벤트를 생성합니다.
- `ZADD`는 (여러 요소를 추가해도) zadd 이벤트 하나를 생성합니다.
- `ZDIFFSTORE`, `ZINTERSTORE`, `ZUNIONSTORE`는 각각 zdiffstore, zinterstore, zunionstore 이벤트를 생성합니다. 결과 정렬셋이 비고 기존 키가 존재했다면, 삭제되어 del 이벤트도 발생합니다.
- `ZINCRBY`는 zincr 이벤트를 생성합니다.
- `ZREMRANGEBYRANK`는 zrembyrank 이벤트를 생성하며, 정렬셋이 비고 키가 제거되면 del 이벤트도 추가됩니다.
- `ZREMRANGEBYSCORE`는 zrembyscore 이벤트를 생성하며, 정렬셋이 비고 키가 제거되면 del 이벤트도 추가됩니다.
- `ZREM`은 (여러 요소를 제거해도) zrem 이벤트 하나만 생성하며, 정렬셋이 비어 키가 제거되면 del 이벤트도 생성됩니다. 또한 다음과 같은 특별 이벤트도 있습니다:
- TTL이 설정된 키가 만료되면 expired 이벤트가 생성됩니다. 
- maxmemory 정책으로 인해 키가 제거되면 evicted 이벤트가 생성됩니다.
- 새로운 키가 데이터셋에 추가될 때마다 new 이벤트가 생성됩니다.

**중요**: 모든 명령어는 대상 키가 실제로 변경될 때만 이벤트를 생성합니다. 예를 들어 `SREM`을 통해 Set에 존재하지 않는 요소를 삭제하면,
키의 값은 실제로 변경되지 않기 때문에 어떤 이벤트로 생성되지 않습니다.

잘 모르겠으면, 직접 해보면 됩니다:

~~~redis
$ redis-cli config set notify-keyspace-events KEA
$ redis-cli --csv psubscribe '__key*__:*'
Reading messages... (press Ctrl-C to quit
"psubscribe","__key*__:*",1
~~~

이 시점에서, 다른 터미널에서 redis-cli를 사용하여 Redis 서버에 명령어를 보내고 생성되는 이벤트를 관찰해보세요:

~~~redis
"pmessage","__key*__:*","__keyspace@0__:foo","set"
"pmessage","__key*__:*","__keyevent@0__:set","foo"
...
~~~

## Timing of expired events

TTL이 설정된 키들은 Redis에서 두 가지 방식으로 만료됩니다:
- 해당 키에 명령어가 접근했을 때, 만료되었을 경우
- 백그라운드에서 만료된 키들을 검색하는 경우(접근되지 않는 키들도 만료 가능)

expired 이벤트는 위 시스템 중 하나가 키를 접근하고 만료했을 경우 생성됩니다. 다른 말로 키가 만료되는 시점에 Redis 서버가 정확히 expired
이벤트를 생성할 것이라는 보장은 없습니다.

어떤 명령어도 키를 지속적으로 접근하지 않고, 많은 키에 TTL에 설정되어 있으면, expired 이벤트가 생성되는 시점과 키가 만료되는 시점에 큰 차이가
있을 수 도 있습니다.

Expired 이벤트는 키가 만료될 때 생성되는 것이 아니라, Redis 서버가 키를 삭제할 때 생성되는 것이 정확합니다.

## Events in a cluster

Redis 클러스터의 각 노드는 위에서 설명된 것처럼 자신이 담당하는 키 공간에 대한 이벤트만 생성합니다. 하지만, 일반적인 클러스터 Pub/Sub과는 달리,
이벤트 알림은 모든 노드에 브로드캐스트되지 않습니다. Keyspace 이벤트는 노드 단위로 발생합니다. 따라서 클러스터의 모든 keyspace 이벤트를 수신하려면,
클라이언트는 각 노드에 개별적으로 구독을 해야 합니다.